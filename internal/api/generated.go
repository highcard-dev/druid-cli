// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gofiber/fiber/v2"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AddPortRequestProtocol.
const (
	Tcp AddPortRequestProtocol = "tcp"
	Udp AddPortRequestProtocol = "udp"
)

// Defines values for CommandInstructionSetRun.
const (
	Always     CommandInstructionSetRun = "always"
	Once       CommandInstructionSetRun = "once"
	Persistent CommandInstructionSetRun = "persistent"
	Restart    CommandInstructionSetRun = "restart"
)

// Defines values for ConsoleType.
const (
	ConsoleTypePlugin  ConsoleType = "plugin"
	ConsoleTypeProcess ConsoleType = "process"
	ConsoleTypeTty     ConsoleType = "tty"
)

// Defines values for ScrollLockStatus.
const (
	Done    ScrollLockStatus = "done"
	Error   ScrollLockStatus = "error"
	Running ScrollLockStatus = "running"
	Waiting ScrollLockStatus = "waiting"
)

// AddPortRequest defines model for AddPortRequest.
type AddPortRequest struct {
	// CheckActivity Whether to monitor port activity
	CheckActivity *bool `json:"check_activity,omitempty"`

	// Description Optional port description
	Description *string `json:"description,omitempty"`

	// Mandatory Whether this port must be open for health check
	Mandatory *bool `json:"mandatory,omitempty"`

	// Name Port name/identifier
	Name string `json:"name"`

	// Port Port number (1-65535)
	Port int `json:"port"`

	// Protocol Network protocol (tcp or udp)
	Protocol AddPortRequestProtocol `json:"protocol"`
}

// AddPortRequestProtocol Network protocol (tcp or udp)
type AddPortRequestProtocol string

// AugmentedPort defines model for AugmentedPort.
type AugmentedPort struct {
	CheckActivity      *bool   `json:"check_activity,omitempty"`
	Description        *string `json:"description,omitempty"`
	FinishAfterCommand *string `json:"finish_after_command,omitempty"`

	// InactiveSince When the port became inactive
	InactiveSince time.Time `json:"inactive_since"`

	// InactiveSinceSec Seconds since port became inactive
	InactiveSinceSec int   `json:"inactive_since_sec"`
	Mandatory        *bool `json:"mandatory,omitempty"`

	// Name Port name/identifier
	Name string `json:"name"`

	// Open Whether the port is currently open
	Open bool `json:"open"`

	// Port Port number
	Port int `json:"port"`

	// Protocol Network protocol
	Protocol     string             `json:"protocol"`
	SleepHandler *string            `json:"sleep_handler"`
	StartDelay   *int               `json:"start_delay,omitempty"`
	Vars         *[]ColdStarterVars `json:"vars,omitempty"`
}

// ColdStarterVars defines model for ColdStarterVars.
type ColdStarterVars struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// CommandInstructionSet defines model for CommandInstructionSet.
type CommandInstructionSet struct {
	Dependencies *[]string   `json:"dependencies,omitempty"`
	Needs        *[]string   `json:"needs,omitempty"`
	Procedures   []Procedure `json:"procedures"`

	// Run Run mode for the command
	Run *CommandInstructionSetRun `json:"run,omitempty"`
}

// CommandInstructionSetRun Run mode for the command
type CommandInstructionSetRun string

// Console defines model for Console.
type Console struct {
	// Exit Exit code if console has exited
	Exit *int `json:"exit"`

	// InputMode Input mode for the console
	InputMode string `json:"inputMode"`

	// Type Console type
	Type ConsoleType `json:"type"`
}

// ConsoleType Console type
type ConsoleType string

// ConsolesResponse defines model for ConsolesResponse.
type ConsolesResponse struct {
	Consoles map[string]Console `json:"consoles"`
}

// Cronjob defines model for Cronjob.
type Cronjob struct {
	Command string `json:"command"`
	Name    string `json:"name"`

	// Schedule Cron schedule expression
	Schedule string `json:"schedule"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Error Error message
	Error  string `json:"error"`
	Status string `json:"status"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Mode Current health status mode
	Mode string `json:"mode"`

	// Progress Progress percentage for loading operations
	Progress *float32 `json:"progress,omitempty"`

	// StartDate When the daemon started
	StartDate *time.Time `json:"start_date"`
}

// Port defines model for Port.
type Port struct {
	// CheckActivity Whether to monitor port activity
	CheckActivity *bool `json:"check_activity,omitempty"`

	// Description Port description
	Description *string `json:"description,omitempty"`

	// FinishAfterCommand Command to run after port is available
	FinishAfterCommand *string `json:"finish_after_command,omitempty"`

	// Mandatory Whether this port must be open for health check
	Mandatory *bool `json:"mandatory,omitempty"`

	// Name Port name/identifier
	Name string `json:"name"`

	// Port Port number
	Port int `json:"port"`

	// Protocol Network protocol
	Protocol string `json:"protocol"`

	// SleepHandler Handler to call when port becomes inactive
	SleepHandler *string `json:"sleep_handler"`

	// StartDelay Delay in seconds before starting port check
	StartDelay *int               `json:"start_delay,omitempty"`
	Vars       *[]ColdStarterVars `json:"vars,omitempty"`
}

// Procedure defines model for Procedure.
type Procedure struct {
	// Data Procedure data payload
	Data interface{} `json:"data,omitempty"`

	// Id Unique procedure identifier
	Id *string `json:"id"`

	// IgnoreFailure Whether to continue on failure
	IgnoreFailure *bool `json:"ignore_failure,omitempty"`

	// Mode Procedure execution mode
	Mode string `json:"mode"`

	// Wait Wait condition
	Wait *Procedure_Wait `json:"wait,omitempty"`
}

// ProcedureWait0 defines model for .
type ProcedureWait0 = string

// ProcedureWait1 defines model for .
type ProcedureWait1 = int

// ProcedureWait2 defines model for .
type ProcedureWait2 = bool

// Procedure_Wait Wait condition
type Procedure_Wait struct {
	union json.RawMessage
}

// Process defines model for Process.
type Process struct {
	// Name Process name/identifier
	Name string `json:"name"`

	// Type Process type
	Type string `json:"type"`
}

// ProcessMonitorMetrics defines model for ProcessMonitorMetrics.
type ProcessMonitorMetrics struct {
	// Connections Active network connections
	Connections []string `json:"connections"`

	// Cpu CPU usage percentage
	Cpu float64 `json:"cpu"`

	// Memory Memory usage in bytes
	Memory int `json:"memory"`

	// Pid Process ID
	Pid int `json:"pid"`
}

// ProcessTreeNode defines model for ProcessTreeNode.
type ProcessTreeNode struct {
	Children   *[]ProcessTreeNode `json:"children,omitempty"`
	Cmdline    *string            `json:"cmdline,omitempty"`
	CpuPercent *float64           `json:"cpu_percent,omitempty"`
	Gids       *[]int             `json:"gids,omitempty"`

	// IoCounters I/O counters
	IoCounters *string `json:"io_counters,omitempty"`

	// Memory Memory statistics
	Memory *string `json:"memory,omitempty"`

	// MemoryEx Extended memory statistics
	MemoryEx *string `json:"memory_ex,omitempty"`
	Name     *string `json:"name,omitempty"`

	// Process Process information (simplified from gopsutil)
	Process  *string `json:"process,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ProcessTreeRoot defines model for ProcessTreeRoot.
type ProcessTreeRoot struct {
	Root                 ProcessTreeNode `json:"root"`
	TotalCpuPercent      float64         `json:"total_cpu_percent"`
	TotalIoCountersRead  int64           `json:"total_io_counters_read"`
	TotalIoCountersWrite int64           `json:"total_io_counters_write"`
	TotalMemoryRss       int64           `json:"total_memory_rss"`
	TotalMemorySwap      int64           `json:"total_memory_swap"`
	TotalMemoryVms       int64           `json:"total_memory_vms"`
	TotalProcessCount    int             `json:"total_process_count"`
}

// ProcessesResponse defines model for ProcessesResponse.
type ProcessesResponse struct {
	Processes map[string]Process `json:"processes"`
}

// QueueResponse Map of command IDs to their execution status
type QueueResponse map[string]ScrollLockStatus

// ScrollFile Scroll configuration file structure
type ScrollFile struct {
	// AppVersion Application version (not necessarily semver)
	AppVersion *string                           `json:"app_version,omitempty"`
	Commands   *map[string]CommandInstructionSet `json:"commands,omitempty"`
	Cronjobs   *[]Cronjob                        `json:"cronjobs,omitempty"`

	// Desc Scroll description
	Desc *string `json:"desc,omitempty"`

	// Init Initialization command
	Init *string `json:"init,omitempty"`

	// KeepAlivePPM Keep alive packets per minute
	KeepAlivePPM *int `json:"keepAlivePPM,omitempty"`

	// Name Scroll name
	Name    *string                       `json:"name,omitempty"`
	Plugins *map[string]map[string]string `json:"plugins,omitempty"`
	Ports   *[]Port                       `json:"ports,omitempty"`

	// Version Scroll version (semver)
	Version *string `json:"version,omitempty"`
}

// ScrollLockStatus Status of a command in the queue
type ScrollLockStatus string

// ScrollLogStream defines model for ScrollLogStream.
type ScrollLogStream struct {
	// Key The log stream identifier
	Key string `json:"key"`

	// Log Array of log lines
	Log []string `json:"log"`
}

// StartCommandRequest defines model for StartCommandRequest.
type StartCommandRequest struct {
	// Command The command ID to execute
	Command string `json:"command"`

	// Sync Whether to run synchronously (wait for completion)
	Sync *bool `json:"sync,omitempty"`
}

// StartProcedureRequest defines model for StartProcedureRequest.
type StartProcedureRequest struct {
	// Data The data payload for the procedure
	Data string `json:"data"`

	// Dependencies List of dependency IDs this procedure depends on
	Dependencies *[]string `json:"dependencies,omitempty"`

	// Mode The procedure mode (e.g., "stdin", or plugin mode)
	Mode string `json:"mode"`

	// Process The process name to run the procedure against
	Process string `json:"process"`

	// Sync Whether to run synchronously
	Sync *bool `json:"sync,omitempty"`
}

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	// Token The generated authentication token
	Token string `json:"token"`
}

// WatchModeRequest defines model for WatchModeRequest.
type WatchModeRequest struct {
	// HotReloadCommands Commands to run when files change
	HotReloadCommands *[]string `json:"hotReloadCommands,omitempty"`

	// WatchPaths Directories to watch
	WatchPaths []string `json:"watchPaths"`
}

// WatchModeResponse defines model for WatchModeResponse.
type WatchModeResponse struct {
	// Enabled Current watch mode state
	Enabled bool `json:"enabled"`

	// Status Result status of the operation
	Status string `json:"status"`
}

// WatchStatusResponse defines model for WatchStatusResponse.
type WatchStatusResponse struct {
	// Enabled Whether watch mode is currently enabled
	Enabled bool `json:"enabled"`

	// WatchedPaths List of currently watched file paths
	WatchedPaths []string `json:"watchedPaths"`
}

// RunCommandJSONRequestBody defines body for RunCommand for application/json ContentType.
type RunCommandJSONRequestBody = StartCommandRequest

// AddPortJSONRequestBody defines body for AddPort for application/json ContentType.
type AddPortJSONRequestBody = AddPortRequest

// RunProcedureJSONRequestBody defines body for RunProcedure for application/json ContentType.
type RunProcedureJSONRequestBody = StartProcedureRequest

// AddCommandJSONRequestBody defines body for AddCommand for application/json ContentType.
type AddCommandJSONRequestBody = CommandInstructionSet

// EnableWatchJSONRequestBody defines body for EnableWatch for application/json ContentType.
type EnableWatchJSONRequestBody = WatchModeRequest

// AsProcedureWait0 returns the union data inside the Procedure_Wait as a ProcedureWait0
func (t Procedure_Wait) AsProcedureWait0() (ProcedureWait0, error) {
	var body ProcedureWait0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcedureWait0 overwrites any union data inside the Procedure_Wait as the provided ProcedureWait0
func (t *Procedure_Wait) FromProcedureWait0(v ProcedureWait0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcedureWait0 performs a merge with any union data inside the Procedure_Wait, using the provided ProcedureWait0
func (t *Procedure_Wait) MergeProcedureWait0(v ProcedureWait0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcedureWait1 returns the union data inside the Procedure_Wait as a ProcedureWait1
func (t Procedure_Wait) AsProcedureWait1() (ProcedureWait1, error) {
	var body ProcedureWait1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcedureWait1 overwrites any union data inside the Procedure_Wait as the provided ProcedureWait1
func (t *Procedure_Wait) FromProcedureWait1(v ProcedureWait1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcedureWait1 performs a merge with any union data inside the Procedure_Wait, using the provided ProcedureWait1
func (t *Procedure_Wait) MergeProcedureWait1(v ProcedureWait1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcedureWait2 returns the union data inside the Procedure_Wait as a ProcedureWait2
func (t Procedure_Wait) AsProcedureWait2() (ProcedureWait2, error) {
	var body ProcedureWait2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcedureWait2 overwrites any union data inside the Procedure_Wait as the provided ProcedureWait2
func (t *Procedure_Wait) FromProcedureWait2(v ProcedureWait2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcedureWait2 performs a merge with any union data inside the Procedure_Wait, using the provided ProcedureWait2
func (t *Procedure_Wait) MergeProcedureWait2(v ProcedureWait2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Procedure_Wait) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Procedure_Wait) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Finish cold start
	// (POST /api/v1/coldstarter/finish)
	FinishColdstarter(c *fiber.Ctx) error
	// Run a command
	// (POST /api/v1/command)
	RunCommand(c *fiber.Ctx) error
	// List all consoles
	// (GET /api/v1/consoles)
	GetConsoles(c *fiber.Ctx) error
	// Stop daemon
	// (POST /api/v1/daemon/stop)
	StopDaemon(c *fiber.Ctx) error
	// Get health status
	// (GET /api/v1/health)
	GetHealthAuth(c *fiber.Ctx) error
	// List all log streams
	// (GET /api/v1/logs)
	ListAllLogs(c *fiber.Ctx) error
	// List logs for a specific stream
	// (GET /api/v1/logs/{stream})
	ListStreamLogs(c *fiber.Ctx, stream string) error
	// Get process metrics
	// (GET /api/v1/metrics)
	GetMetrics(c *fiber.Ctx) error
	// Get port information
	// (GET /api/v1/ports)
	GetPorts(c *fiber.Ctx) error
	// Add a port to watch
	// (POST /api/v1/ports)
	AddPort(c *fiber.Ctx) error
	// Remove a watched port
	// (DELETE /api/v1/ports/{port})
	DeletePort(c *fiber.Ctx, port int) error
	// Run a procedure
	// (POST /api/v1/procedure)
	RunProcedure(c *fiber.Ctx) error
	// Get procedure statuses
	// (GET /api/v1/procedures)
	GetProcedures(c *fiber.Ctx) error
	// List running processes
	// (GET /api/v1/processes)
	GetProcesses(c *fiber.Ctx) error
	// Get process tree
	// (GET /api/v1/pstree)
	GetPsTree(c *fiber.Ctx) error
	// Get command queue
	// (GET /api/v1/queue)
	GetQueue(c *fiber.Ctx) error
	// Get current scroll
	// (GET /api/v1/scroll)
	GetScroll(c *fiber.Ctx) error
	// Add command to current scroll
	// (PUT /api/v1/scroll/commands/{command})
	AddCommand(c *fiber.Ctx, command string) error
	// Create WebSocket token
	// (GET /api/v1/token)
	CreateToken(c *fiber.Ctx) error
	// Disable development mode
	// (POST /api/v1/watch/disable)
	DisableWatch(c *fiber.Ctx) error
	// Enable development mode
	// (POST /api/v1/watch/enable)
	EnableWatch(c *fiber.Ctx) error
	// Get watch mode status
	// (GET /api/v1/watch/status)
	GetWatchStatus(c *fiber.Ctx) error
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

type MiddlewareFunc fiber.Handler

// FinishColdstarter operation middleware
func (siw *ServerInterfaceWrapper) FinishColdstarter(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.FinishColdstarter(c)
}

// RunCommand operation middleware
func (siw *ServerInterfaceWrapper) RunCommand(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.RunCommand(c)
}

// GetConsoles operation middleware
func (siw *ServerInterfaceWrapper) GetConsoles(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetConsoles(c)
}

// StopDaemon operation middleware
func (siw *ServerInterfaceWrapper) StopDaemon(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.StopDaemon(c)
}

// GetHealthAuth operation middleware
func (siw *ServerInterfaceWrapper) GetHealthAuth(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetHealthAuth(c)
}

// ListAllLogs operation middleware
func (siw *ServerInterfaceWrapper) ListAllLogs(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.ListAllLogs(c)
}

// ListStreamLogs operation middleware
func (siw *ServerInterfaceWrapper) ListStreamLogs(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "stream" -------------
	var stream string

	err = runtime.BindStyledParameterWithOptions("simple", "stream", c.Params("stream"), &stream, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter stream: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.ListStreamLogs(c, stream)
}

// GetMetrics operation middleware
func (siw *ServerInterfaceWrapper) GetMetrics(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetMetrics(c)
}

// GetPorts operation middleware
func (siw *ServerInterfaceWrapper) GetPorts(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetPorts(c)
}

// AddPort operation middleware
func (siw *ServerInterfaceWrapper) AddPort(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.AddPort(c)
}

// DeletePort operation middleware
func (siw *ServerInterfaceWrapper) DeletePort(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "port" -------------
	var port int

	err = runtime.BindStyledParameterWithOptions("simple", "port", c.Params("port"), &port, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter port: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.DeletePort(c, port)
}

// RunProcedure operation middleware
func (siw *ServerInterfaceWrapper) RunProcedure(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.RunProcedure(c)
}

// GetProcedures operation middleware
func (siw *ServerInterfaceWrapper) GetProcedures(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetProcedures(c)
}

// GetProcesses operation middleware
func (siw *ServerInterfaceWrapper) GetProcesses(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetProcesses(c)
}

// GetPsTree operation middleware
func (siw *ServerInterfaceWrapper) GetPsTree(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetPsTree(c)
}

// GetQueue operation middleware
func (siw *ServerInterfaceWrapper) GetQueue(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetQueue(c)
}

// GetScroll operation middleware
func (siw *ServerInterfaceWrapper) GetScroll(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetScroll(c)
}

// AddCommand operation middleware
func (siw *ServerInterfaceWrapper) AddCommand(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "command" -------------
	var command string

	err = runtime.BindStyledParameterWithOptions("simple", "command", c.Params("command"), &command, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter command: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.AddCommand(c, command)
}

// CreateToken operation middleware
func (siw *ServerInterfaceWrapper) CreateToken(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.CreateToken(c)
}

// DisableWatch operation middleware
func (siw *ServerInterfaceWrapper) DisableWatch(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.DisableWatch(c)
}

// EnableWatch operation middleware
func (siw *ServerInterfaceWrapper) EnableWatch(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.EnableWatch(c)
}

// GetWatchStatus operation middleware
func (siw *ServerInterfaceWrapper) GetWatchStatus(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetWatchStatus(c)
}

// FiberServerOptions provides options for the Fiber server.
type FiberServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router fiber.Router, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, FiberServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router fiber.Router, si ServerInterface, options FiberServerOptions) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	for _, m := range options.Middlewares {
		router.Use(fiber.Handler(m))
	}

	router.Post(options.BaseURL+"/api/v1/coldstarter/finish", wrapper.FinishColdstarter)

	router.Post(options.BaseURL+"/api/v1/command", wrapper.RunCommand)

	router.Get(options.BaseURL+"/api/v1/consoles", wrapper.GetConsoles)

	router.Post(options.BaseURL+"/api/v1/daemon/stop", wrapper.StopDaemon)

	router.Get(options.BaseURL+"/api/v1/health", wrapper.GetHealthAuth)

	router.Get(options.BaseURL+"/api/v1/logs", wrapper.ListAllLogs)

	router.Get(options.BaseURL+"/api/v1/logs/:stream", wrapper.ListStreamLogs)

	router.Get(options.BaseURL+"/api/v1/metrics", wrapper.GetMetrics)

	router.Get(options.BaseURL+"/api/v1/ports", wrapper.GetPorts)

	router.Post(options.BaseURL+"/api/v1/ports", wrapper.AddPort)

	router.Delete(options.BaseURL+"/api/v1/ports/:port", wrapper.DeletePort)

	router.Post(options.BaseURL+"/api/v1/procedure", wrapper.RunProcedure)

	router.Get(options.BaseURL+"/api/v1/procedures", wrapper.GetProcedures)

	router.Get(options.BaseURL+"/api/v1/processes", wrapper.GetProcesses)

	router.Get(options.BaseURL+"/api/v1/pstree", wrapper.GetPsTree)

	router.Get(options.BaseURL+"/api/v1/queue", wrapper.GetQueue)

	router.Get(options.BaseURL+"/api/v1/scroll", wrapper.GetScroll)

	router.Put(options.BaseURL+"/api/v1/scroll/commands/:command", wrapper.AddCommand)

	router.Get(options.BaseURL+"/api/v1/token", wrapper.CreateToken)

	router.Post(options.BaseURL+"/api/v1/watch/disable", wrapper.DisableWatch)

	router.Post(options.BaseURL+"/api/v1/watch/enable", wrapper.EnableWatch)

	router.Get(options.BaseURL+"/api/v1/watch/status", wrapper.GetWatchStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
